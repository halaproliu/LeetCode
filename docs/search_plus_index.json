{"./":{"url":"./","title":"Introduction","keywords":"","body":"leetcode学习 本项目旨在记录leetcode的刷题之路，记录下问题和解法，以及最终的结果，欢迎大家的指正，谢谢。 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-11 00:33:43 "},"problem/":{"url":"problem/","title":"PART Ⅰ - leetcode算法","keywords":"","body":"leetcode学习 本项目旨在记录leetcode的刷题之路，记录下问题和解法，以及最终的结果，欢迎大家的指正，谢谢。 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-02 22:23:23 "},"problem/面试题08.01-三步问题.html":{"url":"problem/面试题08.01-三步问题.html","title":"面试题08.01-三步问题","keywords":"","body":"leetcode算法-面试题08.01-三步问题 问题描述 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。 示例1: 输入：n = 3 输出：4 说明: 有四种走法 示例2: 输入：n = 5 输出：13 提示: n范围在[1, 1000000]之间 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/three-steps-problem-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {number} n * @return {number} */ var waysToStep = function(n) { let nums = [1, 2, 4] let i if (n 执行结果 执行用时 :116 ms, 在所有 JavaScript 提交中击败了34.83%的用户 内存消耗 :68.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 116ms 68.1MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:37 "},"problem/面试题08.06-汉诺塔问题.html":{"url":"problem/面试题08.06-汉诺塔问题.html","title":"面试题08.06-汉诺塔问题","keywords":"","body":"leetcode算法-面试题08.06-汉诺塔问题 问题描述 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制: (1) 每次只能移动一个盘子; (2) 盘子只能从柱子顶端滑出移到下一根柱子; (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 你需要原地修改栈。 示例1: 输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2: 输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示: A中盘子的数目不大于14个。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/hanota-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {number[]} A * @param {number[]} B * @param {number[]} C * @return {void} Do not return anything, modify C in-place instead. */ var hanota = function(A, B, C) { const len = A.length if (len === 0) return [] function move (A, B, C) { if (C.length === len) return while (A.length > 1) { B.unshift(A.pop()) } C.push(A.pop()) move(B, A, C) } move(A, B, C) return C }; 执行结果 执行用时 :68 ms, 在所有 JavaScript 提交中击败了53.64%的用户 内存消耗 :32.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 68ms 32.3MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:41 "},"problem/1-两数之和.html":{"url":"problem/1-两数之和.html","title":"1-两数之和","keywords":"","body":"leetcode算法-1-两数之和 问题描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 暴力破解法 通过简单的双层循环，进行暴力破解 时间复杂度O(n\b2) /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { for (var i = 0; i hashmap求解法 时间复杂度O(n\b) /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { const hash = {} for (let index = 0; index 执行结果 执行用时 :64 ms, 在所有 JavaScript 提交中击败了90.32%的用户 内存消耗 :35.3 MB, 在所有 JavaScript 提交中击败了27.12%的用户 提交结果 执行用时 内存消耗 通过 64ms 35.3MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:40:36 "},"problem/2-两数相加.html":{"url":"problem/2-两数相加.html","title":"2-两数相加","keywords":"","body":"leetcode算法-2-两数相加 问题描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例: 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-two-numbers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ function ListNode(val) { this.val = val this.next = null } var addTwoNumbers = function(l1, l2) { let dummy = new ListNode(0) // 设置链表开头为0的节点 let cur = dummy let carry = 0 // 进位 while (l1 != null || l2 != null) { let d1 = l1 == null ? 0 : l1.val let d2 = l2 == null ? 0 : l2.val const sum = d1 + d2 + carry // 两数对应位和进位相加 carry = Math.floor(sum / 10) // 计算进位 cur.next = new ListNode(sum % 10) cur = cur.next if (l1 != null) l1 = l1.next if (l2 != null) l2 = l2.next } if (carry > 0) cur.next = new ListNode(carry) return dummy.next // return为0节点后的一个节点即为开始节点 } 执行结果 执行用时 :132 ms, 在所有 JavaScript 提交中击败了70.21%的用户 内存消耗 :38.6 MB, 在所有 JavaScript 提交中击败了80.88%的用户 提交结果 执行用时 内存消耗 通过 132ms 38.6MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:09 "},"problem/3-无重复字符的最长子串.html":{"url":"problem/3-无重复字符的最长子串.html","title":"3-无重复字符的最长子串","keywords":"","body":"leetcode算法-3-无重复字符的最长子串 问题描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { var str = '' var size = 0 for (var i = 0, len = s.length; i 此题使用滑动窗口算法 设置一个对象 使用左右两个指针，遍历字符串，判断对象中是否已包含字符，若不包含，则添加进对象，右指针+1 对比当前无重复子串的长度和最大值，计算出新的最大值 左指针右移，移除一个字符，继续先前的步骤 在枚举结束后，找到的最长子串即是答案 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { const strs = new Set() const len = s.length let r = -1 let max = 0 for (let i = 0; i 执行结果 执行用时 :96 ms, 在所有 JavaScript 提交中击败了82.30%的用户 内存消耗 :39.8 MB, 在所有 JavaScript 提交中击败了61.64%的用户 提交结果 执行用时 内存消耗 通过 96ms 39.8MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:06 "},"problem/4-寻找两个正序数组的中位数.html":{"url":"problem/4-寻找两个正序数组的中位数.html","title":"4-寻找两个正序数组的中位数","keywords":"","body":"leetcode算法-4-寻找两个正序数组的中位数 问题描述 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 解法： 首先合并两个数组 接着对数组进行排序 找到中位数 若数组个数为偶数，则找到中间位两位的前一位的下标，从而找到下一个下标，若为奇数，则直接找到中位数 从而计算出最终的结果 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { var arr = nums1.concat(nums2); arr.sort((a, b) => a - b); var len = arr.length; var midIndex = Math.ceil(len / 2); var mid; if (len % 2 === 0) { mid = (arr[midIndex - 1] + arr[midIndex]) / 2; } else { mid = arr[midIndex - 1]; } return mid; }; 执行结果 执行用时 :164 ms, 在所有 JavaScript 提交中击败了28.80%的用户 内存消耗 :39.7 MB, 在所有 JavaScript 提交中击败了75.00%的用户 提交结果 执行用时 内存消耗 通过 164ms 39.7MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:02 "},"problem/5-最长回文子串.html":{"url":"problem/5-最长回文子串.html","title":"5-最长回文子串","keywords":"","body":"leetcode算法-5-最长回文子串 问题描述 给给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 解法：中心扩散法 遍历字符串，然后区分偶数和奇数两种情况 同时进行两种中心扩散的方式，并取长度最大值 接着可以通过获取的长度和中心点获取到起始和结束的下标 若当前长度最大值大于原先的end-start，则获取新的end和start 最后通过start和end获取最终的结果 /** * @param {string} s * @return {string} */ var longestPalindrome = function (s) { if (!s || s.length { while (l >= 0 && r end - start) { start = i - Math.floor((maxLen - 1) / 2) end = i + Math.floor(maxLen / 2) } } return s.slice(start, end + 1) }; 执行结果 执行用时 :92 ms, 在所有 JavaScript 提交中击败了86.67%的用户 内存消耗 :35.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 92ms 35.6MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:13 "},"problem/6-Z字形变换.html":{"url":"problem/6-Z字形变换.html","title":"6-Z字形变换","keywords":"","body":"leetcode算法-6-Z 字形变换 问题描述 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2: 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zigzag-conversion 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 此解思路为： 创建一个数组，每一个元素为一行。 数组长度为字符串长度和numRows的最小值 若numRows = 1，则说明当前字符串即为最终结果。 初始化两个变量，loc为当前数组下标，down表示是否向下。 遍历字符串 当\bdown = true时，则loc += 1, 数组对应下标数组拼接字符串。 当down = false时，则loc -= 1, 数组对应下标数组拼接字符串。 时间复杂度为：O(n)， n为字符串s的长度 /** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { if(numRows == 1) return s; const len = Math.min(s.length, numRows); const rows = []; for(let i = 0; i 执行结果 执行用时 :112 ms, 在所有 JavaScript 提交中击败了52.15%的用户 内存消耗 :39.5 MB, 在所有 JavaScript 提交中击败了66.67%的用户 提交结果 执行用时 内存消耗 通过 112ms 39.5MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:19 "},"problem/7-整数翻转.html":{"url":"problem/7-整数翻转.html","title":"7-整数翻转","keywords":"","body":"leetcode算法-7-整数翻转 问题描述 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 思路： 首先确认输入参数的正负值 先移除符号位的影响 接着转换到String类型进行翻转 接着对符号位进行处理 最后对数字边界进行处理 /** * @param {number} x * @return {number} */ var reverse = function(x) { let isNegative = x max) return 0 return num }; 执行结果 执行用时 :88 ms, 在所有 JavaScript 提交中击败了70.60%的用户 内存消耗 :35.9 MB, 在所有 JavaScript 提交中击败了77.39%的用户 提交结果 执行用时 内存消耗 通过 88ms 35.9MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:23 "},"problem/8-字符串转换整数.html":{"url":"problem/8-字符串转换整数.html","title":"8-字符串转换整数","keywords":"","body":"leetcode算法-8-字符串转换整数 问题描述 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ' ' 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: \"42\" 输出: 42 示例 2: 输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/string-to-integer-atoi 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 方法一：parseInt 从parseInt的文档可知其特性： 字符串开头的空白符和结尾将会被忽略 parseInt 可以理解两个符号。+ 表示正数，- 表示负数 如果第一个字符不能转换为数字，parseInt会返回 NaN 刚好符合我们本题的要求，同时要注意边界情况。 /** * @param {string} str * @return {number} */ var myAtoi = function(str) { let result = parseInt(str, 10) let INT_MIN = Math.pow(-2, 31) let INT_MAX = Math.pow(2, 31) - 1 if (isNaN(result)) return 0 if (result INT_MAX) return INT_MAX return result }; 方法二：正则表达式 /** * @param {string} str * @return {number} */ var myAtoi = function(str) { let INT_MIN = Math.pow(-2, 31) let INT_MAX = Math.pow(2, 31) - 1 let reg = /^[\\+|\\-)]?\\d+/g let result = str.trim().match(reg) && str.trim().match(reg)[0] return Math.max(Math.min(result, INT_MAX), INT_MIN) || 0 }; 方法三：状态机 状态机分为四种状态，start,signed,in_number,end 遍历字符串，获取每个字符对应的状态 默认状态为start 开头为空格，状态依然为start 当出现第一个字符的时候，若是+或-符号，则为signed，若为数字，则状态为in_number，否则为end /** * @param {string} str * @return {number} */ var myAtoi = function(str) { let state = 'start' let sign = 1 let ans = 0 const table = { start: ['start', 'signed', 'in_number', 'end'], signed: ['end', 'end', 'in_number', 'end'], in_number: ['end', 'end', 'in_number', 'end'], end: ['end', 'end', 'end', 'end'] } const INT_MIN = Math.pow(-2, 31) const INT_MAX = Math.pow(2, 31) - 1 function getCol(c) { if (' ' === c) return 0 if ('+' === c || '-' === c) return 1 if (!isNaN(+c)) return 2 return 3 } function get(c) { state = table[state][getCol(c)] if (state === 'in_number') { ans = ans * 10 + +c - '0' } else if (state === 'signed') { sign = c === '+' ? 1 : -1 } } let chars = str.split('') for (let i = 0; i 执行结果 parseInt 执行用时 :76 ms, 在所有 JavaScript 提交中击败了97.69%的用户 内存消耗 :35.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 76ms 35.7MB 正则表达式 执行用时 :96 ms, 在所有 JavaScript 提交中击败了43.22%的用户 内存消耗 :37.1 MB, 在所有 JavaScript 提交中击败了12.50%的用户 提交结果 执行用时 内存消耗 通过 96ms 37.1MB 状态机 执行用时 :120 ms, 在所有 JavaScript 提交中击败了13.76%的用户 内存消耗 :38.1 MB, 在所有 JavaScript 提交中击败了12.50%的用户 提交结果 执行用时 内存消耗 通过 120ms 38.1MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:31 "},"problem/9-回文数.html":{"url":"problem/9-回文数.html","title":"9-回文数","keywords":"","body":"leetcode算法-9-回文数 问题描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 暴力破解法 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { let tmp = x + '' let arr = tmp.split('') return +arr.reverse().join('') === x }; 取余翻转法 奇数位数：得到的新整数除以10，应与剩余的数相等 偶数位数：得到的新整数本身要与剩余的数相等 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { // if (x 二分对比法 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { if(x 执行结果 暴力破解法 执行用时 : 352 ms, 在所有 JavaScript 提交中击败了5.13%的用户 内存消耗 : 45.8 MB, 在所有 JavaScript 提交中击败了52.00%的用户 提交结果 执行用时 内存消耗 通过 352ms 45.8MB 取余翻转法 执行用时 : 220 ms, 在所有 JavaScript 提交中击败了73.22%的用户 内存消耗 : 45.2 MB, 在所有 JavaScript 提交中击败了82.00%的用户 提交结果 执行用时 内存消耗 通过 220ms 45.2MB 二分对比法 执行用时 : 256 ms, 在所有 JavaScript 提交中击败了33.33%的用户 内存消耗 : 45.7 MB, 在所有 JavaScript 提交中击败了60.00%的用户 提交结果 执行用时 内存消耗 通过 256ms 45.7MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:36 "},"problem/11-盛最多水的容器.html":{"url":"problem/11-盛最多水的容器.html","title":"11-盛最多水的容器","keywords":"","body":"leetcode算法-11-盛最多水的容器 问题描述 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/container-with-most-water 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 此解思路为： 使用双指针法，双向进行 设定left，right，max三个基本变量 盛水部分即为一个矩形，长为right-left的长度，宽为left和right中较低的一个部分 进行遍历循环，获取当前可盛水面积，当前面积大于最大值时，则当前面积为最大值 当left的高度小于right的高度时，则left+1，反之，right+1 /** * @param {number[]} height * @return {number} */ var maxArea = function(height) { let max = 0 let left = 0 let right = height.length - 1 while (left max ? current : max if (height[left] 执行结果 执行用时 :64 ms, 在所有 JavaScript 提交中击败了93.91%的用户 内存消耗 :35.6 MB, 在所有 JavaScript 提交中击败了94.12%的用户 提交结果 执行用时 内存消耗 通过 64 ms 35.6 MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:41 "},"problem/12-整数转罗马数字.html":{"url":"problem/12-整数转罗马数字.html","title":"12-整数转罗马数字","keywords":"","body":"leetcode算法-12-整数转罗马数字 问题描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: \"III\" 示例 2: 输入: 4 输出: \"IV\" 示例 3: 输入: 9 输出: \"IX\" 示例 4: 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/integer-to-roman 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 使用字典保存罗马字符的个十百千位1-10的字符 使用除法获取个十百千位数字，并取模去除最大位数 分别取得个十百千位对应的字符字典值 注意：边界为1-3999 /** * @param {number} num * @return {string} */ var intToRoman = function(num) { if (num 3999) return '' function getDictValue (key, value) { const dicts = { units: ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'], tens: ['X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC'], hundreds: ['C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM'], throusands: ['M', 'MM', 'MMM'] } return dicts[key][value - 1] || '' } let mod = 0 let throusands = ~~(num / 1000) mod = num % 1000 let hundreds = ~~(mod / 100) mod = mod % 100 let tens = ~~(mod / 10) mod = mod % 10 let units = mod let result = getDictValue('throusands', throusands) + getDictValue('hundreds', hundreds) + getDictValue('tens', tens) + getDictValue('units', units) return result }; 执行结果 执行用时 :156 ms, 在所有 JavaScript 提交中击败了81.98%的用户 内存消耗 :43.5 MB, 在所有 JavaScript 提交中击败了20.00%的用户 提交结果 执行用时 内存消耗 通过 156 ms 43.5 MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:46 "},"problem/13-罗马数字转整数.html":{"url":"problem/13-罗马数字转整数.html","title":"13-罗马数字转整数","keywords":"","body":"leetcode算法-13-罗马数字转整数 问题描述 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/roman-to-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {string} s * @return {number} */ var romanToInt = function(s) { let dicts = { 'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1 } let ans = 0, index = 0, now = 0, num = 0 while (index 执行结果 执行用时 :176 ms, 在所有 JavaScript 提交中击败了46.39%的用户 内存消耗 :41.6 MB, 在所有 JavaScript 提交中击败了33.33%的用户 提交结果 执行用时 内存消耗 通过 176 ms 41.6 MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:49 "},"problem/14-最长公共前缀.html":{"url":"problem/14-最长公共前缀.html","title":"14-最长公共前缀","keywords":"","body":"leetcode算法-14-最长公共前缀 问题描述 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { if (!strs.length) return '' if (strs.length === 1) return strs[0] let str = strs[0] let tmpStrs = strs.slice(1) let obj = {} let temp = '' let result = '' for (let i = 0; i { if (item.substr(0, prefix.length) === prefix) { temp = prefix } else { obj[prefix] = 0 } }) if (obj[temp] !== 0) { result = temp } } return result }; 执行结果 执行用时 :68 ms, 在所有 JavaScript 提交中击败了77.74%的用户 内存消耗 :36.9 MB, 在所有 JavaScript 提交中击败了15.15%的用户 提交结果 执行用时 内存消耗 通过 68ms 36.9MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:53 "},"problem/15-三数之和.html":{"url":"problem/15-三数之和.html","title":"15-三数之和","keywords":"","body":"leetcode算法-15-三数之和 问题描述 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 首先对数组进行从小到大排序 循环遍历数组，l指针从i+1开始，r指针则从数组的最右侧开始 当i+l+r第三个数值相加为0时，则满足条件，储存进数组，大于0，则r--,小于0，则l++ 当相邻值相等时，则无需遍历，直接+1 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function(nums) { let l, r, res = [] let arr = nums.sort((a, b) => a - b) for (let i = 0; i 0) break if(nums[i] === nums[i - 1]) continue l = i + 1 r = arr.length - 1 while (l 0) { r-- } else if (sum 执行结果 执行用时 :156 ms, 在所有 JavaScript 提交中击败了97.32%的用户 内存消耗 :46.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 156ms 46.1MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:06:57 "},"problem/16-最接近的三数之和.html":{"url":"problem/16-最接近的三数之和.html","title":"16-最接近的三数之和","keywords":"","body":"leetcode算法-16-最接近的三数之和 问题描述 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum-closest 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function (nums, target) { let l, r, diff, sum = 0, ans let len = nums.length if (len a - b) for (let i = 0; i 执行结果 执行用时 :80 ms, 在所有 JavaScript 提交中击败了73.06%的用户 内存消耗 :36.6 MB, 在所有 JavaScript 提交中击败了10.00%的用户 提交结果 执行用时 内存消耗 通过 80ms 36.6MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:00 "},"problem/17-电话号码的字母组合.html":{"url":"problem/17-电话号码的字母组合.html","title":"17-电话号码的字母组合","keywords":"","body":"leetcode算法-17-电话号码的字母组合 问题描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：\"23\" 输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 思路： 使用递归 /** * @param {string} digits * @return {string[]} */ var letterCombinations = function(digits) { if (!digits) { return []; } var len = digits.length; var map = new Map(); map.set('2','abc'); map.set('3','def'); map.set('4','ghi'); map.set('5','jkl'); map.set('6','mno'); map.set('7','pqrs'); map.set('8','tuv'); map.set('9','wxyz'); var result = []; function _generate(i, str) { if (i === len) { result.push(str); return; } var tmp = map.get(digits[i]); for(var r = 0; r 执行结果 执行用时 :56 ms, 在所有 JavaScript 提交中击败了94.45%的用户 内存消耗 :32.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 56ms 32.3MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:04 "},"problem/18-四数之和.html":{"url":"problem/18-四数之和.html","title":"18-四数之和","keywords":"","body":"leetcode算法-18-四数之和 问题描述 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/4sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function (nums, target) { let l, r, res = [] let len = nums.length if (len a - b) for (let i = 0; i 0 && nums[i] === nums[i - 1]) continue; for (let j = i + 1; j i && nums[j] === nums[j - 1]) continue; while (l 执行结果 执行用时 :124 ms, 在所有 JavaScript 提交中击败了38.93%的用户 内存消耗 :38.4 MB, 在所有 JavaScript 提交中击败了11.11%的用户 提交结果 执行用时 内存消耗 通过 124ms 38.4MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:10 "},"problem/19-删除链表的倒数第N个节点.html":{"url":"problem/19-删除链表的倒数第N个节点.html","title":"19-删除链表的倒数第N个节点","keywords":"","body":"leetcode算法-19-删除链表的倒数第N个节点 问题描述 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { const dummy = new ListNode(0) dummy.next = head let l = dummy let r = dummy let offset = n + 1 while (offset--) { r = r.next if (offset > 1 && r === null) { return dummy.next } } while (r) { r = r.next l = l.next } l.next = l.next.next return dummy.next } 执行结果 执行用时 :76 ms, 在所有 JavaScript 提交中击败了46.67%的用户 内存消耗 :33.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 76ms 33.2MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:14 "},"problem/20-有效的括号.html":{"url":"problem/20-有效的括号.html","title":"20-有效的括号","keywords":"","body":"leetcode算法-20-有效的括号 问题描述 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 思路： 利用栈的功能，如果遇到左括号，直接推入栈中， 遇到右括号，则取出栈顶的元素，如果不匹配则返回false，否则继续匹配。 同时每一个括号都应该有对应的匹配值，所以字符串整体长度应为偶数 /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if (s.length % 2) return false let arr = [] for (let char of s) { switch(char) { case '(': case '[': case '{': arr.push(char) break case ')': if (arr.pop() !== '(') return false break case ']': if (arr.pop() !== '[') return false break case '}': if (arr.pop() !== '{') return false break } } return !arr.length }; 执行结果 执行用时 :68 ms, 在所有 JavaScript 提交中击败了67.06%的用户 内存消耗 :33.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 68ms 33.5MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:18 "},"problem/21-合并两个有序链表.html":{"url":"problem/21-合并两个有序链表.html","title":"21-合并两个有序链表","keywords":"","body":"leetcode算法-21-合并两个有序链表 问题描述 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 使用迭代的方法 通过迭代比较两个链表的值 当前节点的下一项则为较小的值 接着获取next值，继续比较，直到next为null为止 /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { // 创建头节点 let dummy = new ListNode(0) // 创建指针 while (l1 && l2) { if (l1.val 执行结果 执行用时 :80 ms, 在所有 JavaScript 提交中击败了56.25%的用户 内存消耗 :35.5 MB, 在所有 JavaScript 提交中击败了94.12%的用户 提交结果 执行用时 内存消耗 通过 80ms 35.5MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:21 "},"problem/22-括号生成.html":{"url":"problem/22-括号生成.html","title":"22-括号生成","keywords":"","body":"leetcode算法-22-括号生成 问题描述 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 输入：n = 3 输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/generate-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 使用递归回溯法 /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { let res = [] // cur :当前字符 left：当前字符左括号 right:当前字符右括号 const help = (cur, left, right) => { console.log(cur) if (cur.length === 2 * n) { res.push(cur) return } if (left 执行结果 执行用时 :148 ms, 在所有 JavaScript 提交中击败了5.56%的用户 内存消耗 :41.9 MB, 在所有 JavaScript 提交中击败了12.50%的用户 提交结果 执行用时 内存消耗 通过 148ms 41.9MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:25 "},"problem/23-合并K个排序链表.html":{"url":"problem/23-合并K个排序链表.html","title":"23-合并K个排序链表","keywords":"","body":"leetcode算法-23-合并K个排序链表 问题描述 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1->4->5, 1->3->4, 2->6 ] 输出: 1->1->2->3->4->4->5->6 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-k-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 function ListNode(val) { this.val = val; this.next = null; } var mergeTwoLists = function(l1, l2) { // 创建头节点 let dummy = new ListNode(0) // 创建指针 let prev = dummy while (l1 && l2) { if (l1.val 执行结果 执行用时 :108 ms, 在所有 JavaScript 提交中击败了71.19%的用户 内存消耗 :41.4 MB, 在所有 JavaScript 提交中击败了25.00%的用户 提交结果 执行用时 内存消耗 通过 108ms 41.4MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:29 "},"problem/24-两两交换链表中的节点.html":{"url":"problem/24-两两交换链表中的节点.html","title":"24-两两交换链表中的节点","keywords":"","body":"leetcode算法-24-两两交换链表中的节点 问题描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1->2->3->4, 你应该返回 2->1->4->3. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 求解 function ListNode(val) { this.val = val; this.next = null; } /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function(head) { const dummyHead = new ListNode(0) dummyHead.next = head let prev = dummyHead let first = prev.next while (first && first.next) { let second = first.next let next = second.next second.next = first first.next = next prev.next = second prev = first first = first.next } return dummyHead.next } 执行结果 执行用时 : 68ms, 在所有 JavaScript 提交中击败了59.85%的用户 内存消耗 : 32.6MB, 在所有 JavaScript 提交中击败了100.00%的用户 提交结果 执行用时 内存消耗 通过 68ms 32.6MB 更多前端资料请关注公众号 【三分钟热度工程师】 如果觉得写得还不错，可以关注gitbook小册 Copyright © halaproliu.github.io/gitbook 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 22:07:33 "}}