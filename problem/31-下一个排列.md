# leetcode算法-31-下一个排列

### 问题描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
```js
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 求解

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    const len = nums.length;

    if(len <= 2) return nums.reverse();
    let index = len - 2;
    
    while(index > 0){
        if(nums[index] < nums[index + 1]){
            break;
        } 
        index--;
    }
    if(index === 0 && nums.concat().sort((a,b) => b - a)[0] === nums[0] ){
        return nums.reverse();
    }
    let indexOfmin = index + 1;
    let min = nums[indexOfmin] - nums[index];
    
    for(let i = index + 1; i < len; i++){
        if(nums[i] > nums[index] && Math.min(nums[i] - nums[index], min) !== min){
            indexOfmin = i;
        }
    }

    [nums[index], nums[indexOfmin]] = [nums[indexOfmin], nums[index]];
    let arr = nums.slice(index + 1);
    arr.sort((a, b) => a - b);
    for(let i = index + 1; i < len; i++){
        nums[i] = arr[i - index - 1]
    }
    

    return nums
};
```

### 执行结果

```js
执行用时 : 80ms, 在所有 JavaScript 提交中击败了68.59%的用户
内存消耗 : 35.9MB, 在所有 JavaScript 提交中击败了50.00%的用户
```

| 提交结果 | 执行用时 | 内存消耗 |
|:------:|:------:|:-------:|
|   通过  | 80ms  |  35.9MB |

更多前端资料请关注公众号 `【三分钟热度工程师】`

![](../imgs/qrcode.jpg)

如果觉得写得还不错，可以关注[gitbook小册](https://halaproliu.github.io/gitbook/shellmd5/2596084d37a462e93b62f7c136e9eb0e.html)
